<article><div><div><div><a target="_blank" href="https://medium.com/@mertozan?source=post_page-----1aef93c2bc86--------------------------------"><div><p><img alt="Mert Ozan Kahraman" src="https://miro.medium.com/v2/resize:fill:88:88/1*qqjJtbeNaWjlxDcEwNSkWw.jpeg" /></p></div></a></div><figure><figcaption>source of image: <a target="_blank" href="https://medium.com/@lionel.kossi/kotlin-data-class-d231186ef550"><strong>https://medium.com/@lionel.kossi/kotlin-data-class-d231186ef550</strong></a></figcaption></figure><p>Hello everybody, I hope everyone is fine. In this article, I will try to explain Data Classes in Kotlin, What‚Äôs the difference from regular classes? What are the advantages of this data class? I‚Äôm going to answer this question in this article. Is everybody ready; <strong>Let‚Äôs start!</strong></p><figure></figure><h2 id="ecd0">üöÄ<strong>Data Classes</strong></h2><p>For data classes in Kotlin, the purpose is to hold data in that class just like other regular classes. But with <strong><em>data </em></strong>keywords, we can reach many useful things to use. But before explaining these advantages, let‚Äôs talk about the usage requirements of this class.</p><h2 id="4665">- Parameters have to declare with val or var</h2><pre><span>data class PersonData(val name: String,var age: Int) // Data Class<p>class Person(name: String, age: Int) //Regular Class</p></span></pre><p>Basically, this class named ‚ÄúPersonData‚Äù is Data Class and provides all the requirements for using Data Class. It‚Äôs similar to regular classes, but we know, we have no obligation to use the val or var keyword in the primary constructor.</p><h2 id="8703">- Data class parameters are declared in the primary constructor.</h2><p>If we want to use these benefits we have to declare class parameters in the primary constructor. Of course, we can declare that the secondary constructor is within the scope of the class, but we cannot use these advantages for these parameters.</p><h2 id="d1a5">- Data classes have to have a minimum of one parameter in the primary constructor.</h2><p>As we mentioned above, we use data classes for primary constructor parameters. If we want to use the data class for this, we need to give at least one parameter.</p><h2 id="5e18">- Data classes can not be <em>abstract,</em> open, sealed, or inner class.</h2><pre><span>sealed data class Person(val name: String = "Empty")<br /> // This code will be occured error.</span></pre><p>In data class, we can‚Äôt use <em>sealed</em>, <em>open, </em>or <em>inner </em>class keywords. When we use we get ‚ÄúModifier ‚Äòsealed(or, what we declared)‚Äô is incompatible with ‚Äòdata‚Äô ‚õî‚Äù.</p><p>Actually, these rules are not difficult to follow. Is everyone understand? Let‚Äôs look up to what‚Äôs the difference between data classes and regular classes.</p></div><div><h2 id="49df">üÜö What‚Äôs the difference between data classes and regular classes?</h2><figure></figure><p>Let‚Äôs start with how to create these two classes and how to call them.</p><pre><span>data class PlanetData(val name: String,var age: Long) // Data Class<p>class Planet(name: String, val age: Long) //Regular Class</p><p>fun main(){</p><p>    val dataPlanet = PlanetData(name = "Hello World!!", age = 4_500_000_000_000)<br />    val planet = Planet(name = "Hello World!!", age = 4_500_000_000_000)</p><p>}</p></span></pre><p>When we looked at the above first, we can see these two classes look the same. But in Java background, there is a many differences, Let‚Äôs get deep into Java background with Show Kotlin Bytecode.</p><h2 id="f849"><strong><em>Planet.java</em></strong></h2><pre><span>public final class Planet {<br />   private final long age;<p>   public final long getAge() {<br />      return this.age;<br />   }</p><p>   public Planet(@NotNull String name, long age) {<br />      Intrinsics.checkNotNullParameter(name, "name");<br />      super();<br />      this.age = age;<br />   }<br />}</p></span></pre><blockquote><p>‚è¨ Let‚Äôs scroll a little down to see data class‚Äôs :)</p></blockquote><h2 id="97a8">PlanetData.java</h2><pre><span>public final class PlanetData {<br />   @NotNull<br />   private final String name;<br />   private long age;<p>   @NotNull<br />   public final String getName() {<br />      return this.name;<br />   }</p><p>   public final long getAge() {<br />      return this.age;<br />   }</p><p>   public final void setAge(long var1) {<br />      this.age = var1;<br />   }</p><p>   public PlanetData(@NotNull String name, long age) {<br />      Intrinsics.checkNotNullParameter(name, "name");<br />      super();<br />      this.name = name;<br />      this.age = age;<br />   }</p><p>      // for Destructing Declarations<br />   @NotNull<br />   public final String component1() {<br />      return this.name;<br />   }</p><p>   public final long component2() {<br />      return this.age;<br />   }</p><p>   @NotNull<br />   public final PlanetData copy(@NotNull String name, long age) { </p><p>        // for copy() function   </p><p>        Intrinsics.checkNotNullParameter(name, "name");<br />      return new PlanetData(name, age);<br />   }</p><p>   // $FF: synthetic method<br />   public static PlanetData copy$default(PlanetData var0, String var1, long var2, int var4, Object var5) {<br />      if ((var4 &amp; 1) != 0) {<br />         var1 = var0.name;<br />      }</p><p>      if ((var4 &amp; 2) != 0) {<br />         var2 = var0.age;<br />      }</p><p>      return var0.copy(var1, var2);<br />   }</p><p>   @NotNull<br />   public String toString() {</p><p>      // for toString() function</p><p>      return "PlanetData(name=" + this.name + ", age=" + this.age + ")";<br />   }</p><p>   public int hashCode() {</p><p>      // for hashCode() function</p><p>      String var10000 = this.name;<br />      return (var10000 != null ? var10000.hashCode() : 0) * 31 + Long.hashCode(this.age);<br />   }</p><p>   public boolean equals(@Nullable Object var1) {</p><p>      // for equals() function</p><p>      if (this != var1) {<br />         if (var1 instanceof PlanetData) {<br />            PlanetData var2 = (PlanetData)var1;<br />            if (Intrinsics.areEqual(this.name, var2.name) &amp;&amp; this.age == var2.age) {<br />               return true;<br />            }<br />         }</p><p>         return false;<br />      } else {<br />         return true;<br />      }<br />   }<br />}</p></span></pre><figure></figure><p>That‚Äôs the difference between these two classes.</p><p>But why data class create that automatically in the Java background? What are these good for? Let‚Äôs jump to the data class‚Äôs advantages.</p></div><div><h2 id="1486">Data class advantages</h2><p>If we examine PlanetData.java a little we can see some function declarations. But what are that functions? Let‚Äôs have a look.</p><figure></figure><h2 id="56b1">Copy Function</h2><p>Assume we have a data class assigned to a property and we want to new property with the same data class but with other values. In that case, we can use the .copy() function.</p><pre><span>val dataPlanet = PlanetData(name = "Hello World!!", age = 500)<p>val newDataPlanet = dataPlanet.copy(name = "Hello Mars!!", age = 32)</p></span></pre><p>We can change all values -and remainder; if these are the first constructor parameters- with the copy() function. With that, we avoid creating new data class objects.</p><h2 id="6121">Equals Function</h2><p>With the .equals() function, we can compare two data classes to the primary constructors‚Äô values. But we can use the ‚Äú==‚Äù operator too.</p><pre><span>println(dataPlanet.equals(newDataPlanet)) // false<p>println(dataPlanet == newDataPlanet) // false again</p></span></pre><h2 id="9c59">toString Function</h2><p>Actually, the toString() function is the same function as what we always use for variables.</p><pre><span>val dataPlanet = PlanetData(name = "Hello World!!", age = 500)<br />println("String: ${dataPlanet.toStirng()}")<p>// Printed -&gt; PlanetData(name = "Hello World!!", age = 500)</p></span></pre><h2 id="0f77">Destructing Declarations</h2><p>Our last thing in the data class is to destroy the declarations. With this, we can assign class values to variables with the key/value method. Let‚Äôs have a look.</p><pre><span>val(name,age) = dataPlanet<p>println("Name: $name Age: $age")</p></span></pre><p>How this can be possible in the data class, Remain that code</p><pre><span>// PlanetData.java<br />...<br />   // for Destructing Declarations<br />   @NotNull<br />   public final String component1() {<br />      return this.name;<br />   }<p>   public final long component2() {<br />      return this.age;<br />   }</p><p>...</p></span></pre><p>Values are assigned one by one with componentN method. <a href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank">Anything can be on the right-hand side of a destructuring declaration, as long as the required number of component functions can be called on it. And, of course, there can be </a><code><a href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank">component3()</a></code><a href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank"> , and </a><code><a href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank">component4()</a></code><a href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank"> so on.</a></p><p>End of this article‚Ä¶</p><figure></figure><p>I‚Äôm I am very happy to try to explain this subject to you. I hope I made it. Thanks for reading my article for more articles you can visit my Medium account. If you have any questions, you can contact me through these accounts.</p><blockquote><p><strong>Twitter: </strong><a href="https://twitter.com/meetozan" target="_blank">https://twitter.com/meetozan</a></p><p><strong>Github: </strong><a href="https://github.com/meetOzan" target="_blank">https://github.com/meetOzan</a></p><p><strong>Linkedin: </strong><a href="https://www.linkedin.com/in/mert-ozan-kahraman-578b23234/" target="_blank">https://www.linkedin.com/in/mert-ozan-kahraman-578b23234/</a></p></blockquote></div></div></article>